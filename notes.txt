create  node js project
run initalialy server on port
create a custom image wrting configs in Dockerfile
after configuring the docker file create an image
stop the nodejs project from local
sudo docker build . ------------------- . means in current directory 
sudo docker images ls ---------------to see all the images
sudo docker image rm 99ecbb57ee84 ----------------to remove the specific images by using id
sudo docker build -t node-app-image . ------------------here -t flag is passed to give it a name
create a container 
/*
--------   docker run -d --name node-app node-app-image
------1. docker run: This is the primary command to create and run a new container from a Docker image.

2. -d

: This flag stands for "detached mode." It means the container will run in the background, and you won't see its output directly in your terminal. You can use docker logs node-app to view its output later.

3. --name node-app: This option assigns a user-friendly name to the container, making it easier to reference and manage. In this case, the container will be named "node-app".

4. node-app-image: This is the name of the Docker image that you want to run. It contains the packaged application and all its dependencies.

In summary, this command:

    Starts a new container in detached mode from the image named "node-app-image".
    Assigns the name "node-app" to the container for easy identification.
    Runs the application within the container in the background.

Additional notes:

    If the image is not available locally, Docker will attempt to pull it from a remote registry.
    After running this command, you can use docker ps to list running containers and docker logs node-app to view the container's logs.
*/

sudo docker rm container name or id and container image or id
sudo docker rm node-app node-app-image
bind the port on which we listen on our browser

sudo docker run -d --name node-app -p 3000:3000 node-app-image

//to go inside the container

 sudo docker exec -it node-app bash
root@2566a8f74017:/app# ls
Dockerfile  index.js  node_modules  notes.txt  package-lock.json  package.json
root@2566a8f74017:/app# 
we moved to by default app directroy which is because weh have SET workflow/app
see there is a docker file also in side a container but we do not need it inside a container that because we use COPY . .
MAY BE we also do not need env file inside of container
and also we are getting nodemoudles inside our container but we do not need this because we are copy package.json an dusing command npm install
so for this we use .dockerignore file like gitignore

to delete the container
sudo docker rm node-app -f

now add .dockerignore file and add the files which you want to be ignored


-------------
sync our source code to the docker container so that we can see our changes without rebuilding the image
for this use below command which is called Bind Mount Volume

docker run -v $(pwd):/app -p 3000:3000 -d --name node-app node-app-image
--------     -v is for volume     $(pwd):/app        $(pwd)---this is the present working directory of local system :the directory in container which is /app

-now make changes in code and see it inside the container by using command

docker exec -it node-app bash
root@8550499f0bab:/app# ls
Dockerfile  node_modules  package-lock.json
index.js    notes.txt	  package.json
root@8550499f0bab:/app# cat index.js 
const express = require("express");
const app = express();

app.get("/", (req, res) => {
    res.send("<h2>HI There! Shuaib</h2>");
});
const port = process.env.PORT || 3000;

app.listen(port, () => console.log(`listening on port ${port}`));
root@8550499f0bab:/app# cat index.js 
const express = require("express");
const app = express();

app.get("/", (req, res) => {
    res.send("<h2>HI There it s me</h2>");
});
const port = process.env.PORT || 3000;

app.listen(port, () => console.log(`listening on port ${port}`));
root@8550499f0bab:/app# 

see we are able to see changes inside the container but still we are unable to see the changes on our browser
becasue when we changes the file we need to restart the node process also 
so for this we use to install nodemon as dev dependency and update the commad cmd in dockerfile also CMD ["npm","run","dev"]


now if we delte the node_modules form our local system it will creates problem the container will stopped working becasue bindmout method is copying the whole folder when it is syncing our code so now there is no nodemone there no node_modules so 
we can fix this by 

we cna using anonymous docker volume which reference the node_modules folder -v /app/node_modules
it means while syncing it will not over ride the app directory it simply add other files not replace with new files or folders and it will not touch the nodemoudles folder


docker run -v $(pwd):/app -v /app/node_modules -p 3000:3000 -d --name node-app node-app-image

in our docker file there is COPY . ./ ----IT Is important perhaps the bind mount method is syncing our code but it is only for development but in production we will not use bindmount


when we use bindmount it is two way sync if you add files in locals it will automatically added in container and you have already delted the node_moudles folder but when you rebuild images it comes back because it is due to bindmout sync method

so we need to use ro flag which means read only docker run -v $(pwd):/app:ro -v /app/node_modules -p 3000:3000 -d --name node-app node-app-image

see the realtime example below
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker run -v $(pwd):/app:ro -v /app/node_modules -p 3000:3000 -d --name node-app node-app-image
adb646d40af2be5ecb9e89e2a69b9c69a8b322be1da03fe75259f82f54c3b0ec
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker exec  -it node-app bash
root@adb646d40af2:/app# ls
Dockerfile  node_modules  package-lock.json
index.js    notes.txt	  package.json
root@adb646d40af2:/app# touch testfile
touch: cannot touch 'testfile': Read-only file system
root@adb646d40af2:/app# 

now we can not create file inside container but in vscode we create a file it will be displayed there becuase of bindmount sync

I AM using ENV now
ENV PORT=3000
# SERVER will be running on this port
EXPOSE ${PORT}
let see in realtime example here 
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker run -v $(pwd):/app:ro -v /app/node_modules --env PORT=8000 -p 3000:5000 -d --name node-app node-app-image
b81e4434973eec39d5e71c5cc6cce879d36e99ca7116b535cc578ece643a3d71
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker exec  -it node-app bash
root@b81e4434973e:/app# printenv
HOSTNAME=b81e4434973e
YARN_VERSION=1.22.19
PWD=/app
PORT=5000
HOME=/root
TERM=xterm
SHLVL=1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
NODE_VERSION=20.0.0
_=/usr/bin/printenv
root@b81e4434973e:/app# 


now create a file of .env add PORT=8000
i.e ------i have added --env.file with path ./.env
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker run -v $(pwd):/app:ro -v /app/node_modules --env-file ./.env -p 3000:5000 -d --name node-app node-app-image8818166d53a85e3f0df754dcd2c374d847cdee0850b2fe25458174ebe7fb4dc2
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker exec  -it node-app bash
root@8818166d53a8:/app# printenv
HOSTNAME=8818166d53a8
YARN_VERSION=1.22.19
PWD=/app
PORT=8000
HOME=/root
TERM=xterm
SHLVL=1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
NODE_VERSION=20.0.0
_=/usr/bin/printenv
root@8818166d53a8:/app# 


see about volumes 
docker volume ls
DRIVER    VOLUME NAME
local     5e90cbe352dbbdc969879777bf569cfe608e241dc64328b4c7a5d08698d60254
local     6ed7ee56d36d75f8889b682bc951e771fce38c6b0f289d8001e36c1e305ddcfd
local     9e084a0eb86ae0745d1281c05cad39f26ec3a4748990bdbcebb0e58fa152ec0d
local     50da1c53da438cbba9d178d59b5b58016833c547fd54826818ee586c2a0a5d61
local     59a32963f23495e69739f38182d71daa871127b0d18b321a961355511a99eee2
local     volume-devops-clever_wescoff
 when ever we delete the container it preserved the /app/node_modules every time

sometime these volume contains the databse like postgres may be we donot dlete it
 
 so we can delete it manually
docker volume prune ------it will delte the all volumes 
docker volume rm VOLUME NAME
 --
 OR when we delte the container
 docker rm node-app -fv ----------use v flage with f it will delete the volume associalted with node-app container

 ---------------

 now added docker-compose.yml

docker-compose up -d
[+] Building 14.4s (10/10) FINISHED                                                               docker:default
 => [node-app internal] load .dockerignore                                                                  0.0s
 => => transferring context: 105B                                                                           0.0s
 => [node-app internal] load build definition from Dockerfile                                               0.0s
 => => transferring dockerfile: 932B                                                                        0.0s
 => [node-app internal] load metadata for docker.io/library/node:20.0-slim                                  3.2s
 => [node-app 1/5] FROM docker.io/library/node:20.0-slim@sha256:702d475af4b8045f701afd10ea865f4454e9aab4fe  0.0s
 => [node-app internal] load build context                                                                  0.0s
 => => transferring context: 47.04kB                                                                        0.0s
 => CACHED [node-app 2/5] WORKDIR /app                                                                      0.0s
 => [node-app 3/5] COPY package.json .                                                                      0.0s
 => [node-app 4/5] RUN npm install                                                                         10.6s
 => [node-app 5/5] COPY . ./                                                                                0.0s
 => [node-app] exporting to image                                                                           0.4s
 => => exporting layers                                                                                     0.4s
 => => writing image sha256:c339c942755e743a2d61d7099176b149981823a59f46837631eeddf1ac7b076a                0.0s 
 => => naming to docker.io/library/docker-nodejs-node-app                                                   0.0s
[+] Running 2/2
 ✔ Network docker-nodejs_default       Created                                                              0.1s 
 ✔ Container docker-nodejs-node-app-1  Started            

commands of docker compose 
docker-compose ps
NAME                       IMAGE                    COMMAND                  SERVICE             CREATED             STATUS              PORTS
docker-nodejs-node-app-1   docker-nodejs-node-app   "docker-entrypoint.s…"   node-app            4 minutes ago       Up 4 minutes        0.0.0.0:3000->3000/tcp, :::3000->3000/tcp

dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker-compose ps -a
NAME                       IMAGE                    COMMAND                  SERVICE             CREATED             STATUS              PORTS
docker-nodejs-node-app-1   docker-nodejs-node-app   "docker-entrypoint.s…"   node-app            4 minutes ago       Up 4 minutes        0.0.0.0:3000->3000/tcp, :::3000->3000/tcp

dlete the container with anonymouse volumes associated with the container

dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker-compose down -v
[+] Running 2/2
 ✔ Container docker-nodejs-node-app-1  Removed                                                              0.8s 
 ✔ Network docker-nodejs_default       Removed   


 docker-compose up -d
[+] Running 2/2
 ✔ Network docker-nodejs_default       Created                                                              0.1s 
 ✔ Container docker-nodejs-node-app-1  Started                                                              0.2s 
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker images
REPOSITORY                  TAG                                        IMAGE ID       CREATED             SIZE
node-app-image              latest                                     00e9e39b1abb   About an hour ago   260MB
<none>                      <none>                                     ac7b736abae1   2 hours ago         260MB
<none>                      <none>                                     4333dcbf2e58   2 hours ago         260MB
<none>                      <none>                                     ff9bb7a831ad   2 hours ago         255MB
hello-world                 latest                                     d2c94e258dcb   10 months ago       13.3kB
crazymax/linguist           7.20.0                                     dc5f9ae3be6a   22 months ago       72.2MB
docker/desktop-git-helper   5a4fca126aadcd3f6cc3a011aa991de982ae7000   efe2d67c403b   2 years ago         44.2MB
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker-compose images
CONTAINER                  REPOSITORY               TAG                 IMAGE ID            SIZE
docker-nodejs-node-app-1   docker-nodejs-node-app   latest              c339c942755e        257MB
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ 

if you want to rebuild images
use ---- docker-compose up -d --build      now  it will rebuild


%%%%%%%% Docker Compose Dev to Prod multiple files %%%%%%%%%%

we are npm run dev in dockerfile it runs node mone but it is only in development mode 
---first rename docker-compose.backup.yml
--create new files for different environments
---- docker-compose.dev.yml
---- docker-compose.prod.yml
---- docker-compose.yml

create diffent config for development and production mode

here it is in development mode
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d
[+] Running 2/2
 ✔ Network docker-nodejs_default       Created     0.1s 
 ✔ Container docker-nodejs-node-app-1  Started     0.2s 

stopping container with removing anonymous volumes
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker-compose -f docker-compose.yml -f docker-compose.dev.yml down -v
[+] Running 2/2
 ✔ Container docker-nodejs-node-app-1  Removed     0.9s 
 ✔ Network docker-nodejs_default       Removed     0.4s 

 now try with production mode 
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

in production mode you will not see any change becasue it has no bindmount volumes which sync code becasue it only works in develpemnt mode so now if you want to change you need to rebuild the image to see changes
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d --build ------it will force to create a new build

and add docker-compose* in dockerignore file name which starts with docker-compose do not save it in container

go in container and see nodemon is still there in production mode 
docker-compose ps
NAME                       IMAGE                    COMMAND                  SERVICE             CREATED              STATUS              PORTS
docker-nodejs-node-app-1   docker-nodejs-node-app   "docker-entrypoint.s…"   node-app            About a minute ago   Up 55 seconds       0.0.0.0:3000->3000/tcp, :::3000->3000/tcp
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker-compose exec -it docker-nodejs-node-app-1 bash
service "docker-nodejs-node-app-1" is not running
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker-compose exec -it node-app bash
root@722843de1437:/app# ls
index.js  node_modules	package-lock.json  package.json
root@722843de1437:/app# cd node_modules/
root@722843de1437:/app/node_modules# ls
abbrev		      depd			has-proto	   minimatch	   semver
accepts		      destroy			has-symbols	   ms		   send
anymatch	      ee-first			hasown		   negotiator	   serve-static
array-flatten	      encodeurl			http-errors	   nodemon	   set-function-length
balanced-match	      es-define-property	iconv-lite	   nopt		   setprototypeof
binary-extensions     es-errors			ignore-by-default  normalize-path  side-channel
body-parser	      escape-html		inherits	   object-inspect  simple-update-notifier
brace-expansion       etag			ipaddr.js	   on-finished	   statuses
braces		      express			is-binary-path	   parseurl	   supports-color
bytes		      fill-range		is-extglob	   path-to-regexp  to-regex-range
call-bind	      finalhandler		is-glob		   picomatch	   toidentifier
chokidar	      forwarded			is-number	   proxy-addr	   touch
concat-map	      fresh			lru-cache	   pstree.remy	   type-is
content-disposition   function-bind		media-typer	   qs		   undefsafe
content-type	      get-intrinsic		merge-descriptors  range-parser    unpipe
cookie		      glob-parent		methods		   raw-body	   utils-merge
cookie-signature      gopd			mime		   readdirp	   vary
debug		      has-flag			mime-db		   safe-buffer	   yallist
define-data-property  has-property-descriptors	mime-types	   safer-buffer
root@722843de1437:/app/node_modules# 

so how can we prevent the devDependencies like nodemon to tak ean extra space
add this line in dockerfile    

RUN npm install --only=production i means there should be something like this so see below how can we do like this
so we have written an embedded bash script
ARG NODE_ENV
RUN if[ "$NODE_ENV" = "development" ];\
         then  npm install;\
         else npm install --only=production:\
         fi


and do some changes to 
docker-compose.dev.yml file
node-app:
  build:
    context: . //this is the path of dockerfile
    args:
      NODE_ENV:development  //this is the ARG WHich we used in dockerfile


      add same in docker-compose.prod.yml


see how our bash embeded script is working while making build
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d --build
[+] Building 55.7s (10/10) FINISHED                                                               docker:default
 => [node-app internal] load .dockerignore                                                                  0.0s
 => => transferring context: 120B                                                                           0.0s
 => [node-app internal] load build definition from Dockerfile                                               0.0s
 => => transferring dockerfile: 1.24kB                                                                      0.0s
 => [node-app internal] load metadata for docker.io/library/node:20.0-slim                                  3.8s
 => [node-app 1/5] FROM docker.io/library/node:20.0-slim@sha256:702d475af4b8045f701afd10ea865f4454e9aab4fe  0.0s
 => [node-app internal] load build context                                                                  0.0s
 => => transferring context: 400B                                                                           0.0s
 => CACHED [node-app 2/5] WORKDIR /app                                                                      0.0s
 => CACHED [node-app 3/5] COPY package.json .                                                               0.0s
 => [node-app 4/5] RUN if [ "production" = "development" ]; then         npm install;     else         np  49.9s
 => [node-app 5/5] COPY . ./                                                                                0.1s
 => [node-app] exporting to image                                                                           0.2s
 => => exporting layers                                                                                     0.2s
 => => writing image sha256:2b23db45477cea8df5015a2ea3a7e73e608ae469380a3103cc53eab5b3e79010                0.0s
 => => naming to docker.io/library/docker-nodejs-node-app                                                   0.0s
[+] Running 2/2
 ✔ Network docker-nodejs_default       Created                                                              0.1s 
 ✔ Container docker-nodejs-node-app-1  Started       

now see no node_modules docker-compose exec -it node-app bash

root@a67cbe2ecd1c:/app# ls
index.js  node_modules	package-lock.json  package.json
root@a67cbe2ecd1c:/app# cd node_modules/
root@a67cbe2ecd1c:/app/node_modules# ls
accepts		      ee-first		  has-property-descriptors  mime-types	    send
array-flatten	      encodeurl		  has-proto		    ms		    serve-static
body-parser	      es-define-property  has-symbols		    negotiator	    set-function-length
bytes		      es-errors		  hasown		    object-inspect  setprototypeof
call-bind	      escape-html	  http-errors		    on-finished     side-channel
content-disposition   etag		  iconv-lite		    parseurl	    statuses
content-type	      express		  inherits		    path-to-regexp  toidentifier
cookie		      finalhandler	  ipaddr.js		    proxy-addr	    type-is
cookie-signature      forwarded		  media-typer		    qs		    unpipe
debug		      fresh		  merge-descriptors	    range-parser    utils-merge
define-data-property  function-bind	  methods		    raw-body	    vary
depd		      get-intrinsic	  mime			    safe-buffer
destroy		      gopd		  mime-db		    safer-buffer
root@a67cbe2ecd1c:/app/node_modules# 


now we are adding an other service which is basically mongodb services
which will be runing on other container as a service
add mongo in docker-compose
version: "3"
services:
    node-app:
        build: .
        ports:
            - "3000:3000"
        environment:
            - PORT=3000
    # adding a database we can name it anythinlike mongo or mongodb
    mongo:
        image: mongo
        environment:
            - MONGO_INITDB_ROOT_USERNAME=shuaib
            - MONGO_INITDB_ROOT_PASSWORD=shuaib


ev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d --build
[+] Running 9/9
 ✔ mongo 8 layers [⣿⣿⣿⣿⣿⣿⣿⣿]      0B/0B      Pulled                                                       430.9s 
   ✔ bccd10f490ab Pull complete                                                                            79.6s 
   ✔ b00c7ff578b0 Pull complete                                                                             2.2s 
   ✔ a1f43ab85151 Pull complete                                                                             4.8s 
   ✔ 9e72f6a5998a Pull complete                                                                             5.8s 
   ✔ 8424336879e4 Pull complete                                                                             7.5s 
   ✔ 85a6d3c2e6c8 Pull complete                                                                             7.6s 
   ✔ c533c21e5fb8 Pull complete                                                                           410.8s 
   ✔ 1fddf702bb73 Pull complete                                                                             9.9s 
[+] Building 3.4s (10/10) FINISHED                                                                docker:default
 => [node-app internal] load .dockerignore                                                                  0.0s
 => => transferring context: 120B                                                                           0.0s
 => [node-app internal] load build definition from Dockerfile                                               0.0s
 => => transferring dockerfile: 1.24kB                                                                      0.0s
 => [node-app internal] load metadata for docker.io/library/node:20.0-slim                                  3.3s
 => [node-app internal] load build context                                                                  0.0s
 => => transferring context: 155B                                                                           0.0s
 => [node-app 1/5] FROM docker.io/library/node:20.0-slim@sha256:702d475af4b8045f701afd10ea865f4454e9aab4fe  0.0s
 => CACHED [node-app 2/5] WORKDIR /app                                                                      0.0s
 => CACHED [node-app 3/5] COPY package.json .                                                               0.0s
 => CACHED [node-app 4/5] RUN if [ "development" = "development" ]; then         npm install;     else      0.0s
 => CACHED [node-app 5/5] COPY . ./                                                                         0.0s
 => [node-app] exporting to image                                                                           0.0s
 => => exporting layers                                                                                     0.0s
 => => writing image sha256:abd25df727c9d3cb9fe27727784157b95990cfef7317adbd3fc5d269e5bda211                0.0s
 => => naming to docker.io/library/docker-nodejs-node-app                                                   0.0s
[+] Running 2/2
 ✔ Container docker-nodejs-mongo-1     Started                                                              1.4s 
 ✔ Container docker-nodejs-node-app-1  Started                                                             12.1s 
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ 

let see mongodb is connected with a new container docker-compose ps
NAME                       IMAGE                    COMMAND                  SERVICE             CREATED              STATUS              PORTS
docker-nodejs-mongo-1      mongo                    "docker-entrypoint.s…"   mongo               About a minute ago   Up About a minute   27017/tcp
docker-nodejs-node-app-1   docker-nodejs-node-app   "docker-entrypoint.s…"   node-app            About a minute ago   Up About a minute   0.0.0.0:3000->3000/tcp, :::3000->3000/tcp


go inside mongo container service
docker-compose exec -it mongo bash
root@26de13c59fcf:/# mong
bash: mong: command not found
root@26de13c59fcf:/# mongo
bash: mongo: command not found
root@26de13c59fcf:/# mongosh
Current Mongosh Log ID:	66005e7d79f2fd5e69db83af
Connecting to:		mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+2.2.0
Using MongoDB:		7.0.7
Using Mongosh:		2.2.0

For mongosh info see: https://docs.mongodb.com/mongodb-shell/

test> 
(To exit, press Ctrl+C again or Ctrl+D or type .exit)
test> 
root@26de13c59fcf:/# mongo -u root -p shuaib
bash: mongo: command not found
root@26de13c59fcf:/# mongosh -u root -p shuaib
Current Mongosh Log ID:	66005e9ed0677525c9db83af
Connecting to:		mongodb://<credentials>@127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+2.2.0
Using MongoDB:		7.0.7
Using Mongosh:		2.2.0

For mongosh info see: https://docs.mongodb.com/mongodb-shell/

------
   The server generated these startup warnings when booting
   2024-03-24T16:59:58.281+00:00: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine. See http://dochub.mongodb.org/core/prodnotes-filesystem
   2024-03-24T16:59:59.057+00:00: Soft rlimits for open file descriptors too low
------

test> show dbs
admin   100.00 KiB
config   12.00 KiB
local    72.00 KiB
test> 

ok so if you delete the container and rerun the up command without --build flag
and again go to mongo service you see the old created data is destroyed

but in the case of data base i do not want to loose it

create a volume wiht human readabel name it is same like anonymous volume but it has a meaningfull name 

updated dockerfile to persist data inside the volum mongo-db data/db
  mongo:
        image: mongo
        restart: always
        environment:
            - MONGO_INITDB_ROOT_USERNAME=root
            - MONGO_INITDB_ROOT_PASSWORD=shuaib
        volumes:
            - mongo-db:/data/db


volumes:
    mongo-db:
  //may be there are multiple services


now simply use without using -v flag which deltes all the volummes associated with the containers
docker-compose -f docker-compose.yml -f docker-compose.dev.yml down
[+] Running 3/3
 ✔ Container docker-nodejs-node-app-1  Removed                                                              0.8s 
 ✔ Container docker-nodejs-mongo-1     Removed                                                              0.3s 
 ✔ Network docker-nodejs_default       Removed           

 if you want to use 
 docker volume prune 
 first you need to start container now it will not delte the volumes which are assocaiated with contaienrs

 now see data is persisting still after deleting the 
 

 -----------
 configuring mongoose 
 so inspect the container to get ip address information
 docker inspect docker-nodejs-node-app-1

 in last section you will see Networks:
  "Networks": {
                "docker-nodejs_default": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": [
                        "docker-nodejs-node-app-1",
                        "node-app",
                        "a685f438b041"
                    ],
                    "NetworkID": "a370cda5df5a1d4e97d1f141cf63e6acc6eb7a446af6a10e1a91e4f862247f13",
                    "EndpointID": "cfadc4739d6d55c9f0f1a957a34910187cbf9bd91da8b6551b2eb45d57eef5ba",
                    "Gateway": "172.30.0.1",
                    "IPAddress": "172.30.0.3",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:1e:00:03",
                    "DriverOpts": null
                }
            }



      now inspect mongo container

      docker inspect docker-nodejs-mongo-1
  
 "MacAddress": "",
            "Networks": {
                "docker-nodejs_default": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": [
                        "docker-nodejs-mongo-1",
                        "mongo",
                        "164193f8f66b"
                    ],
                    "NetworkID": "a370cda5df5a1d4e97d1f141cf63e6acc6eb7a446af6a10e1a91e4f862247f13",
                    "EndpointID": "7679a2e265c6d282321bde8e6527775dd6c25fcfac5d1372e0a731e0684c624b",
                    "Gateway": "172.30.0.1",
                   IPAddress": "172 ".30.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:1e:00:02",
                    "DriverOpts": null
                }

we will use this mongo ip address in mongourl
                   IPAddress": "172.30.0.2",

but this is not a good practice to inspect container and see the address because when we dlete the contaner and re run create ip will be chaned every time there will be a new ip address of each container

when one container communicates to other container we need a DNS 
SEE Thisdocker network ls
NETWORK ID     NAME                    DRIVER    SCOPE
2ddaf9a63f2e   bridge                  bridge    local
a370cda5df5a   docker-nodejs_default   bridge    local
c5472cc1287e   host                    host      local
0d4556146a70   none                    null      local
dev@dev-Latitude-5490:~/Desktop$ 

 docker-nodejs_default-----------THIS is created by docker-compose

 so replace the ip address with mongo which is our service name
    .connect("mongodb://root:shuaib@172.30.0.2:27017")
    .connect("mongodb://root:shuaib@mongo:27017")


mongo is dns automaticallyget ip address

to see logs continously 
docker logs docker-nodejs-node-app-1 -f


------------------
now when it comes to start docker container specially using docker-compose
we run both container and mongo container ------it should actually knows the order both are running same time it can lead a issue if our node container runs first it will try to connect with database
however our database is still not up it will crash our application

we need a way to docker container to load our mongo instance or contianer load up first so that we can ensure that our data base is connected succesfully then node container should connect to it

so we need this behaviour while development or production mode
we make some changes in docker-compose file

we have added this code depends_on it will first run mongo
services:
    node-app:
        build: .
        ports:
            - "3000:3000"
        environment:
            - PORT=3000
        depends_on:
            - mongo

see now our mongo container starts first
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d
[+] Running 3/3
 ✔ Network docker-nodejs_default       Created                                                              0.1s 
 ✔ Container docker-nodejs-mongo-1     Started                                                              0.0s 
 ✔ Container docker-nodejs-node-app-1  Started    

------but this still does not fixed technically our issue
because it just running the mongo container but not checking it that is it fully initialzed or not or database is listening or not
it is just spin up the container mongo and nodeapp container is ready to connect it
so for this we need to run some logic in our code we should not rely on any orchestor or docker-compose tool 
we should handle scenario in our code it will try to connect retrying unitill mongo run and up but docker try only '30s'

this is the logic it will always retry after 5s but may be this is not a good practice
const connectWithRetry = () => {
    mongoose
        .connect(mongoUrl)
        .then(() => console.log("successfully conned to the database"))
        .catch((e) => {
            console.log("error", e);
            setTimeout(connectWithRetry, 5000);
        });
};

now lets run only node-app service by using --no-deps flage now it will not rely on depends_on property

dock-compose -f docker-compose.yml -f docker-compose.dev.yml up -d --no-deps node-app

lets see each five seconds it gives error message 
docker logs  docker-nodejs-node-app-1 -f

> docker-nodejs@1.0.0 dev
> nodemon index.js

[nodemon] 3.1.0
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,cjs,json
[nodemon] starting `node index.js`
listening on port 3000
error MongooseServerSelectionError: getaddrinfo EAI_AGAIN mongo
    at _handleConnectionErrors (/app/node_modules/mongoose/lib/connection.js:875:11)
    at NativeConnection.openUri (/app/node_modules/mongoose/lib/connection.js:826:11) {
  reason: TopologyDescription {
    type: 'Unknown',
    servers: Map(1) { 'mongo:27017' => [ServerDescription] },
    stale: false,
    compatible: true,
    heartbeatFrequencyMS: 10000,
    localThresholdMS: 15,
    setName: null,
    maxElectionId: null,
    maxSetVersion: null,
    commonWireVersion: 0,
    logicalSessionTimeoutMinutes: null
  },
  code: undefined
}
error MongooseServerSelectionError: getaddrinfo EAI_AGAIN mongo
    at _handleConnectionErrors (/app/node_modules/mongoose/lib/connection.js:875:11)
    at NativeConnection.openUri (/app/node_modules/mongoose/lib/connection.js:826:11) {
  reason: TopologyDescription {
    type: 'Unknown',
    servers: Map(1) { 'mongo:27017' => [ServerDescription] },
    stale: false,
    compatible: true,
    heartbeatFrequencyMS: 10000,
    localThresholdMS: 15,
    setName: null,
    maxElectionId: null,
    maxSetVersion: null,
    commonWireVersion: 0,
    logicalSessionTimeoutMinutes: null
  },
  code: undefined
}


in last we have added todo app cruds 

now we have added redis for session managemnet with expreess-session
redis image as a service

we are using -V   which is because we have added new packages and redis is database so it  is not in old anonymouse volume nodemdules folder that why it creates a new volum which includes all new dependenceies in node modules

docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d -V --build
[+] Building 24.9s (10/10) FINISHED                                                               docker:default
 => [node-app internal] load build definition from Dockerfile                                               0.0s
 => => transferring dockerfile: 1.24kB                                                                      0.0s
 => [node-app internal] load .dockerignore                                                                  0.0s
 => => transferring context: 120B                                                                           0.0s
 => [node-app internal] load metadata for docker.io/library/node:20.11.1                                    4.7s
 => [node-app 1/5] FROM docker.io/library/node:20.11.1@sha256:e06aae17c40c7a6b5296ca6f942a02e6737ae61bbbf3  0.0s
 => [node-app internal] load build context                                                                  0.0s
 => => transferring context: 64.59kB                                                                        0.0s
 => CACHED [node-app 2/5] WORKDIR /app                                                                      0.0s
 => [node-app 3/5] COPY package.json .                                                                      0.0s
 => [node-app 4/5] RUN if [ "development" = "development" ]; then         npm install;     else         n  19.4s
 => [node-app 5/5] COPY . ./                                                                                0.0s 
 => [node-app] exporting to image                                                                           0.6s 
 => => exporting layers                                                                                     0.6s 
 => => writing image sha256:d837e8e018f11462eb92c0495f8f3ae2ba6bafb1c2f0f65db8f9960a83c1bdf8                0.0s 
 => => naming to docker.io/library/docker-nodejs-node-app                                                   0.0s 
[+] Running 4/4                                                                                                  
 ✔ Network docker-nodejs_default       Created                                                              0.1s 
 ✔ Container docker-nodejs-mongo-1     Started                                                              0.0s 
 ✔ Container docker-nodejs-redis-1     Started                                                              0.0s 
 ✔ Container docker-nodejs-node-app-1  Started                                                              0.4s 
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ 



--------
adding nginx config and image

now we no longer publish ports to our node application

now we have configured nginx as a reverse proxy and let test working for load balancer 
i have run two instance of node-app first it will send request to node-docker-node-app-1 and then node-docker-node-app-2 it means loadbalancer is working fine

dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d --scale node-app=02
[+] Running 6/6
 ✔ Network docker-nodejs_default       Created     0.1s 
 ✔ Container docker-nodejs-nginx-1     Started     0.0s 
 ✔ Container docker-nodejs-redis-1     Started     0.0s 
 ✔ Container docker-nodejs-mongo-1     Started     0.0s 
 ✔ Container docker-nodejs-node-app-2  Started     0.4s 
 ✔ Container docker-nodejs-node-app-1  Started     0.4s 
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ 

first instance node-app-1 
docker logs docker-nodejs-node-app-1 -f

> node-docker@1.0.0 dev
> nodemon -L index.js

[nodemon] 2.0.22
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node index.js`
(node:32) DeprecationWarning: current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.
(Use `node --trace-deprecation ...` to show where the warning was created)
(node:32) [MONGODB DRIVER] Warning: Current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.
listening on port 3000
(node:32) DeprecationWarning: collection.ensureIndex is deprecated. Use createIndexes instead.
successfully connected to the database
check load balancer it runs


second instance node-app-2
dev@dev-Latitude-5490:~/Desktop/DevOps/docker-nodejs$ docker logs docker-nodejs-node-app-2 -f

> node-docker@1.0.0 dev
> nodemon -L index.js

[nodemon] 2.0.22
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node index.js`
(node:32) DeprecationWarning: current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.
(Use `node --trace-deprecation ...` to show where the warning was created)
(node:32) [MONGODB DRIVER] Warning: Current Server Discovery and Monitoring engine is deprecated, and will be removed in a future version. To use the new Server Discover and Monitoring engine, pass option { useUnifiedTopology: true } to the MongoClient constructor.
listening on port 3000
(node:32) DeprecationWarning: collection.ensureIndex is deprecated. Use createIndexes instead.
successfully connected to the database
check load balancer it runs


----------------%%%%%%%%%Deploying Production section%%%%%%%%%%
---------
now i have created aws ec2 instance and create .env and copy my envs from This docker file
add all those in env file

-ls -al 
nao .profile
add this script there in last    set -o allexport; source /home/ubuntu/.env; set -o allexport
and close the terminal and connect again with ec2 instance then see --------printenv to see all of your env virables  

ubuntu@ip-172-31-35-180:~$ nano .profile 
ubuntu@ip-172-31-35-180:~$ printenv
SHELL=/bin/bash
MONGO_PASSWORD=shuaib
PWD=/home/ubuntu
LOGNAME=ubuntu
MONGO_INITDB_ROOT_PASSWORD=shuaib
XDG_SESSION_TYPE=tty
NODE_ENV=production
MONGO_INITDB_ROOT_USERNAME=root
_=/usr/bin/printenv
MONGO_USER=root
MOTD_SHOWN=pam
LINES=30
HOME=/home/ubuntu


now make dir in apps/clone repo inside it

now run docekr compose commnadn to make images and container

------ docekr-compose -f docker-compose.yml -f docker-compose.prod.yml up -d 
